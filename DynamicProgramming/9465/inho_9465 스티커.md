# 9465 스티커

#### 문제



2xn 스티커에서 변을 공유하는 스티커는 함께 선택될 수 없다고 가정했을 때, 선택된 조합의 최대 점수를 구해라

![img](https://www.acmicpc.net/upload/images/sticker.png)

n (1 ≤ n ≤ 100,000), 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 

---

#### 해설



| **50** | 10   | 100  | 20   | 40   |
| ------ | ---- | ---- | ---- | ---- |
| 10     | 50   | 70   | 10   | 60   |

제일 왼쪽 ```d[0][0]``` 과 ```d[1][0]```부터 우측으로 점수를 더해가며 최대 점수를 찾는다.



 ```d[0][1]``` 과 ```d[1][1]```은 최댓값이 무조건 왼쪽에서 대각선으로 더해진 값이므로  표는 이렇게 수정된다. 

| 50   | 20   | 100  | 20   | 40   |
| ---- | ---- | ---- | ---- | ---- |
| 10   | 100  | 70   | 10   | 60   |



이런 구성에서  ```d[0][2]``` 가 자신을 포함했을 때 가지는 최대 점수는 

Max( 계속 대각선으로 지그재그 하며 더해온 값인  ```d[1][1]``` (100)+ 자기자신,

​					한 col지나서 있는 ```d[1][0]```(10) + 자기자신)  이다.

```d[1][1]``` 이 더 크므로  ```d[0][2]```  는 100+ 100 = 200  이 된다.



마찬가지로   ```d[1][2]``` 가 자신을 포함했을 때 가지는 최대 점수는 

Max( 계속 대각선으로 지그재그 하며 더해온 값인  ```d[0][1]```(20) + 자기자신,

​					한 col지나서 있는 ```d[0][0]``` (50)+ 자기자신)  이다.

```d[0][0]``` 이 더 크므로  ```d[1][2]```  는 50+ 70 = 120  이 된다.

 

따라서 수정된 결과를 보면

| 50   | 20   | 200  | 20   | 40   |
| ---- | ---- | ---- | ---- | ---- |
| 10   | 100  | 120  | 10   | 60   |

같은방식으로 계속 진행한 후의 결과는 

| 50   | 20   | 200  | 140  | 250  |
| ---- | ---- | ---- | ---- | ---- |
| 10   | 100  | 120  | 210  | 260  |



마지막 열의 두 숫자중 큰 숫자를 골라 출력하면 원하는 결과를 얻을 수 있다.



```java
import java.util.Scanner;
public class Boj9465 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
		int number = sc.nextInt();
		int [] arr= new int[number];
		
		for (int k=0; k<number; k++) {
			int num = sc.nextInt();
			
			int [][] d = new int[2][num];
			
			for(int i=0; i<2; i++) {
				for(int j=0; j<num; j++) {
					d[i][j] = sc.nextInt();
				}
			}
			d[0][1] += d[1][0];
			d[1][1] += d[0][0];
			for (int i=2; i<num; i++) {
				if(d[1][i-2] > d[1][i-1]) {
					d[0][i] += d[1][i-2];
				}
				else {
					d[0][i] += d[1][i-1];
				}
				if(d[0][i-2] > d[0][i-1]) {
					d[1][i] += d[0][i-2];
				}
				else {
					d[1][i] += d[0][i-1];
				}
			}
			
			if (d[0][num-1] >d[1][num-1]) {
				arr[k] =  d[0][num-1];
			}
			else {
				arr[k] =  d[1][num-1];		
			}
			System.out.println(arr[k]);	
		}
		
	}

}
```